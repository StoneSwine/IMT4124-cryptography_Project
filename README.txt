# GeffesGenerator_assessment
Project in the course IMT4124 - Cryptology. This project will use geffes generator (stream cipher) to encrypt a plaintext file. Then the program shows an ciphertext only attack-method proposed by T. Siegenthaler in 1985 to recover the plaintext. The program is implemented in python3, which is not the fastest programming language out there and certainly not the best choice when it comes to bruteforcing. On the other hand it is quite easy to debug and write, which is the main reason behind the choice of programming language.

# Installation:
In a preferred environment, run the follwing command to install the requirements
$ pip install -r requirements.txt
$ python3 main.py #run the program

# TASK 1:
## Implementation:
Task 1 and 3 are implemented in the file './src/main.py'. The function 'task1' reads plaintext from the file specified in the global variable 'INFILE' and returns the ciphertext as an array of bits. Where the key (initial state) is specified in the global variable 'Z{1,2,3}S'. The class 'lfsr' is the implementation of a left shift feedback register (LFSR) and is initialised with an array 'l' that represents the polynomial connections. It is assumed that '1' is always a part of the polynomial, and thus not a part of the array. Considering the primitive polynomial 'x⁴+x+1' the corresponding initializing array would be '[4,1]'. A lfsr instance is responsible for its own output bits (period), generated by the function 'next_o'. Three LFSRs classes are initialised before the bits of the plain text file is added to the running key sequence generated from the combining function defined in 'gg_combining_function'. Several different texts are provided in the repository for testing purposes. In order to make the plaintext as realistic to human written text as possible text from various Wikipedia articles have been concatenated into the files '{1,2,3,4,5}000_example.txt'. The files contains 1000 - 5000 characters (bytes), to demonstrate different lengths of input files.

# TASK 3:
## Implementation
Task 3 use the ciphertext from task 1 as input, as well as the polynomials used in the LFSR's in order to find the keys. Firstly, a correlation attack on the sequence z1 (R1) is performed, and candidate initial states obtained. Next, the same type of attack is conducted on Z3 (R3). A default false positive value of 0.002 (0.2\%), and ciphertext length of 8000 bits is used in order to find the candidate initial-states with the least amount of false positives and reasonable runtime. The performance was greatly increased by creating the whole period of the LFSR before computing the alpha value. Lastly, Z2 is determined by exhaustive search. To make program a bit quicker, the variable 'DEMO' makes the search stop when the correct initial state is found. To create the statistics from the output, the boolean variable 'INCLUDE_STATISTICS' can make the program create the graphs in the report.

Example output:
  ########### TASK 1 ###########
  [TASK1]: Initial setup of polynomials..
  [TASK1]: Information about LFSRs:

    ID     POLYNOMIAL                    INITIAL STATE

    LFSR1  1+x^1+x^3+x^7+x^10            1000101000 (69)
    LFSR2  1+x^5+x^6+x^8+x^12+x^15+x^20  10111110000000000000 (190)
    LFSR3  1+x^1+x^3+x^7+x^11            10001111100 (574)

  [TASK1]: Generating ciphertext from ./plaintextfiles/1000_example.txt with Geffes generator
  ########### TASK 3 ###########
  [TASK3]: correlation from thruth table z1,z2,z3 ->  [0.75, 0.5, 0.75]
  [TASK3]: Running correlation attack on z1
  [TASK3]: Information about variables:
          pe: 0.5499999999999998
          pm: 5.415035086997477e-10
          pf: 0.002
          l: 8000 bit
          T: 257.4
          Ri: 10
  [TASK3]: Seed | Alpha
  [TASK3]: 227  | 258
  [TASK3]: 687  | 274
  [TASK3]: 69  | 380
  [TASK3]: z1-candidates: [227, 687, 69]
  - - - - - - - - - -
  [TASK3]: Running correlation attack on z3
  [TASK3]: Information about variables:
          pe: 0.5499999999999998
          pm: 5.415035086997477e-10
          pf: 0.002
          l: 8000 bit
          T: 257.4
          Ri: 11
  [TASK3]: Seed | Alpha
  [TASK3]: 574  | 380
  [TASK3]: 1721  | 264
  [TASK3]: z3-candidates: [574, 1721]
  - - - - - - - - - -
  [TASK3]: Commencing bruteforce of z2
  [TASK3]: Using Shannons entropy to determine if the plaintext is found
  [TASK3]: Possible seeds | Z1:69 | Z2:190 | Z3:574 | entropy of text: 4.51
  [TASK3]: The correct seed is found, stopping the bruteforce for demonstration purposes...

# TASK 4:
## Implementation
Task 4 is implemented in the file './src/find_best_combiner.py'. The program use truth table analysis in order to find the best output of the non-linear combiner. All of the 2^8-1 (all zeroes is omitted), different output combinations are checked against requirements, which can be adjusted. The boolean variable 'BALANCED' adjusts whether the sequence must be balanced or not. 'CORR_RES_ORD_ONE' and 'CORR_RES_ORD_TWO' specifies the number of inputs which is not correlating with any of the outputs (1-3) in correlation order one and two. 'NON_LIN_ORD' specifies the nonlinear order of the output sequence.

An example output from the program is:
  f(x):[1, 1, 1, 1, 1, 0, 0, 1] --> 6
        correlation immune order 1:[0.25, 0.5, 0.5]
        correlation immune order 2:[0.5, 0.5, 0.25]
        Non linear order: 2 --> ['000', '101', '110']
